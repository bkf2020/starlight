['already solved this problem earlier', 'maybe consider finding the minimum prefix instead of the maximum subarray?', 'keep in mind to store whether a number is in the first half/second half\nyou can store {number, index}']
AtCoder ARC138: C. Rotate and Play Game
["Tried a greedy but it wasn't quite there. In a greedy where you try to add things, you need to add so the things that can be added is MAXIMIZED", 'Try looking to see if after adding something you can add "adjacent" ones/anymore (consider going backwards versus going forwards)', 'Greedy was a bit tedious to implement though... (maybe not too bad)...', 'Simplier solution is to create conditions based on the answer; general idea is to try converting the constraints into something more manageable', 'take advantage of mods to create "buckets", can force there to be <= total added/mod values in each "bucket"', 'can be extended to groups of nums >= 1, nums >= 2, nums >= 3, etc.']
Codeforces 1342D: Multiple Testcases
['When doing a dp that requires the last k elements and/or first k elements (or something like that), consider just storing those in a set like "sliding window" (or use a segtree?)', 'be careful of a greedy, it may not be optimal to include everything that can be covered by some operation', "cool idea from SSRS: maybe represent the dp transitions as a graph especially if you can go backward; use dijsktra's to find the minimum", 'be careful in an interval problem to include the elements at the start of the interval', 'be more clear in defining a dp state: if you include i in dp_i then you need to start at dp_0; 1 indexed in this case going from l to r actually seems to mean you can start at dp_(r+1)']
Codeforces 1216F: Wi-Fi
['Got the intended solution, but going to write some lessons', 'When constructing an answer, start by determining the easiest/simpliest info possible (e.g. the start of a sequence)', 'When a problem wants you to "decode" some given value/array to find the answer (original thing that was applied on), consider making a case (maybe about size 10?) and decoding that. Create better examples than what the problem gives.', 'Maybe when a problem gives the last value something occured, you want to think about "jumping" from one group to another', "Implementation thing: look out for setting a 'first' boolean when you haven't printed anything. If you need something to be at the back of a vector, consider swaping it", 'Maybe be more clear with yourself for what you want. Verbalize it clearly (simple terms as possible) for future problems.']
Codeforces 1738D: Permutation Addicts
['Spent a while thinking about each bit at a time (actually suboptimal)', "In the future, check the bounds of the answer, and play around with the sample input, don't ignore it", 'Maybe when the cost of something involves floor/ceiling and depends on the number of terms, consider using 1/2 terms at a time', "If the numbers you have are a_1, a_2, a_3, .... a_n-1, a_n = (a_1^a_2^a_3^a_4^...^a_n) then that means you have a_1^a_2^a_3^...^a_n=0. In general be willing to consider if the operation over all numbers can help you get a simpler condition. Maybe also be willing to consider cases like this with larger n than the sample input to make sure you haven't missed anything. (again this idea was from the sample input)", 'Prefix sums of xor can detect if a subarray has xor of 0.', 'In a greedy, you probably want the ending to be as EARLY as possible and NOT the beginning.', 'You can take advantage that if 1 more than the previous ending had the same xor, then that value must be 0']
Codeforces 1718A2: Burenka and Traditions (hard version)
['Got the intended solution, but going to write some lessons', 'Take advantage of anything in the problem with low constraints (e.g. value between 0 and 100)', 'in a dp problem, consider fixing the values of something (e.g. the array) and compute the answer from there. Then, try extending those ideas to a general case.', 'take advantage of increasing an ADJACENT row by 1. This usually means that if a_i<a_i+1, then you have to start additional numberings. You should consider comparing adjacent numbers. (Maybe we can extend to comparing adjacent numbers when increasing some adjacent part [or maybe any part] of an array.)', 'Once again, use prefix sums/suffix sums/data structures like segtree or multiset/set to store the last k values or first k values of a dp. This can speed things up.', 'Also, take advantage of storing - l', 'x (or something similiar) to take care of (r - l)', 'x if the segment is [l,r]. Basically break up the expression involving the range, if possible.', 'You can reduce states of a dp by using two arrays (e.g. store dp[j] and new_dp[j] to deal with dp[i][j] and dp[i + 1][j]). Also, ask yourself if all arrays you are using are really used. You can delete some arrays to help with memory. And maybe use just plain old arrays instead of c++ vectors.', 'Be careful that the base case of a dp is implemented correctly. When getting WA, double check to see if the base case implementation doesn\'t miss anything present in the "regular" dp.']
DMOJ DMPG '18 G2 - Gardening Fun
['Got the intended solution, but going to write some lessons', 'When trying to find the minimum/maximum answer in a tree, this may be a hint to involve dp. Consider a dp on each subtree.', 'When applying an operation of a node and then applying that to its parent, this may mean the value of each node involves that operation (or some variation on the subtree of that node)', 'Be careful that just because a node has no one than one child does NOT mean that we only selected nodes forming straight disjoint paths!', 'Be careful that selecting nodes on a path MAY require that node to satisfy some condition regarding the operation (e.g. being the mminimum/maximum in a subtree)']
Codeforces 1740E: Hanging Hearts
['Got the intended solution, but going to write some lessons', 'For a greedy, you may want to go backwards (largest to smallest); basically you want to MAXIMIZE the number of choices for other people (or maybe minimize in other cases)', "Don't get stuck on one approach. Be willing to actually think about and expand vague ideas you have in your head instead of thinking about the same approach that won't work", 'Say things out loud, maybe just write some basic ideas out if stuck and try looking into all of those']
Codeforces 1759G: Restore the Permutation
['Got the intended solution, but going to write some lessons', 'read the problem carefully, the sum is at least X not equal to X... just look over the problem statement twice, maybe read it out loud or use text to speech.', 'when you want the minimum index so a_i >= number, then you should store a monotonic set', 'careful about comparing pairs that can have overlap {val, idx}!', 'be careful about adding prefix 0 (sum = 0, nothing added) in a set', 'when a problem wants the sum in a "circular" fashion, this basically boils down to the sum of the entire set a certain number of times and then some prefix. Maybe try something with that prefix (e.g. selecting the max/min).']
Codeforces 1490G: Old Floppy Drive 
['Got the intended solution, but going to write some lessons', 'Try seeing if you can reframe a problem where the sum of something should be a perfect square into differences in perfect squares. Differences in perfect squares let you use a^2-b^2=(a-b)(a+b)', 'When dealing with something that involves the sum of each prefix, consider storing the possible values of those prefixes in an array, that may be easier to work with', 'When working with something given every even/odd term and some conditions must be satisfied, maybe consider "pairing" things up (like store the possible values of an even,odd pair)', 'Side note: O(NlogN) solution to find number of factors; for each factor loop through all numbers for which it will be a factor (actually better even if you need to check all divisors)', 'make sure you divide the array number a_i, when checking the factors, not i!', 'be careful about assuming that just because the product of (x-y)(x+y) satisfies some condition, x and y also satisfy that condition; generally try to keep the conditions in your code as "simple" or "original" to what you want as possible if the time constraints allow for it. no need to waste time debugging wrong code this way']
Codeforces 1081E: Missing Numbers
["Wasn't really sure where to start, so ended up using the editorial. Tried doing some thinking assuming if you know the places piece 1 or 2 goes to, you can directly compute the answer.", 'Try reframing if the conditions (e.g. those involving distance) force you to visit something or some value to be something', 'like in a graph if the distance between two nodes must be <= d, then you must visit the dth ancestor of a node', 'also consider this idea of dfs order to find the shortest path from certain nodes you have to visit.', 'Be careful to remember that you must visit the root, also be careful if you need to return back to the root nodes']
Codeforces 1774E: Two Chess Pieces
['Got the intended solution, going to write some lessons', 'Take advantage of anything in the problem with low constraints (e.g. value between 0 and 100)', 'Even if your program takes care of edge cases in dp with an array watch out for cases where you add something to this edge case and wrongly update the answer', 'But be careful about updating for i=0/1. maybe you NEED to do so in this case', 'set up good test cases for yourself to debug your program', "watch out for computing the cost in a dp (don't write 1 for i); maybe write down what you think is going to be correct and actually check that!", 'be careful of doing i - 1 if i represents something in a range that is NOT continuous', 'take advantage of removing one component of a dp array by storing two arrays and updating those arrays for increasing i', 'you can also speed up a dp by reframing dp[i] from ONLY i to all values LESS than/GREATER than i', 'In a problem involving replacing numbers and you want the minimum number of something, write down possible operations. Consider storing the operation as something with value v_i and cost c_i. This can be generalized for dp possibly.', "Be willing to try new ideas if the current idea isn't working too great. Know when to stop thinking too long about something.", "See if you can force the values you are picking up in a dp to be increasing/decreasing. Maybe it's just as optimal if you are making operations which increase by index of that operation. This can help you out."]
DMOJ COCI '19 Contest 4 #3 Holding
['See what move must/can be made always; can help you out', "Maybe try complementary counting, seeing the case that won't work... See how you can force there to only be certain moves making the case not work", "Try working out some small cases out (active problem solving); try to continue pumping out new ideas, don't get too stuck on one idea", 'read the problem carefully; check if the length is 1 to n; read it out loud before starting', "Try to do the least work possible? Keep it simple. If you want to compute (a_0 - a_1) + (a_1 - a_2) + ... + (a_n-1 - a_n); maybe just store a_0 and a_n, don't bother trying to find the remaining (can be faster too)", 'If you want gcd(a_1,a_2,a_3,a_4,...a_n, x) > 1, then x does NOT have to be the lcm... x just needs to contain the prime divisors of a_1,a_2,...,a_n']
Codeforces 1749D: Counting Arrays
['once again; given subset find answer for that is very powerful', 'also maybe do some thinking based on taking a possible optimal solution and making it better (or at least the same)???', 'think about just using one person/move for a certain component (e.g. value of b for this problem)', 'side note: when setting ans=0, check if the answer could be lower possibly..', 'just because i < n and j < i does NOT mean i < j. So be careful of using pref[j] in this case because it may NOT already cover i.', 'If you have two options of selecting one option and then determining the other option, consider "reversing this". E.g. start with fixing the second operation, try finding the first operation. This can be much easier to do while the other way maybe hard/impossible.']
Codeforces 1379C: Choosing flowers
['a good idea is to convert some condition (e.g. "carries") into a numerical condition.', 'take advantage that numbers only have a few digits. maybe 6 digits can allow you to do a bitmask and test all 10^6 numbers', 'maybe when dealing with something that involves 1<=a_i<=b_i for some values of i, consider representing dp[c_1][c_2]..[c_n] meaning ways with a_i <= c_i. Then take advantage of "PIE" by choosing which numbers are going to be added/subtracted by 1', 'you can simplify PIE by using bitmasks!', 'careful about including (i,i) when considering pairs!']
AtCoder ARC136: D. Without Carry
['when dealing with something that doubles/powers of 2, you first probably want to use the largest powers of 2 possible', 'be able to distinguish between differences that result relate to values in the array and differences in prefixes! write this down', 'maybe to make thinking about differences in values easier, just consider the values you want to use first (maybe you can use sorting to make things easier if the values have to increase), and then find the differences that way']
Codeforces 1348D: Phoenix and Science
['Was on the right track by splitting the tree into a bunch of buds that were children of the root', 'Make try transforming the problem into the simpliest case possible to work with', 'try to keep it simple when dealing with making moves; maybe try converting the move into subtracting 1 from the possible answer or something to make it easier to find the best moves', 'To make things more efficient and simpler, try finding things that are desired (in this case buds) when running the dfs. Maybe use two numbers to store if a node is a bud/leaf. Maybe see if nodes must be one of two things.']
Codeforces 1566E: Buds Re-hanging
['Got the intended solution, going to write some lessons', 'being able to change the order (e.g. forwards vs backwards or fix variable b instead of variable a) in which you do somehting in is a good idea', "see in a problem where you are trying to optimize a suboptimal solution, which steps are being repeated that don't need to be", 'maybe consider fixing one variable/constraint/object and find the answer from there', 'be careful when doing two pointers! It ends up taking O(N) time total versus binary search which is O(log N) per move. If you are relying on the moves to be less than a number, using two pointers might TLE', 'be careful of increasing something before you check the condition! do what you want to do with the pointer and THEN increase the pointer AFTER.']
Codeforces 1320C: World of Darkraft: Battle for Azathoth
['Was on the right track, but the implementation was too slow', 'You can reframe P.I.E. to using the number of total pairs over the entire subset (look at applying whatever thing you are computing the array as whole instead of for a particular index, can speed it up)', 'Avoid using sets/vectors in a map if possible (maybe change plans if it is too slow)! Try using a custom struct with plain old arrays. Note you can initialize things in a struct like this {0, {44}} where the values are the order in a struct (or just define a blank struct, initialize using dot notation)']
USACO 2018 December Contest, Gold: Cowpatibility
['Got the correct solution eventually, gonna write the lessons', "Try seeing if the interval you are using the problem must start or end at certain locations. Try to use all the conditions given in the problem, ask what intervals wouldn't make sense.", "Double check in a two pointers, whether you will have to REUSE a pointer. If so, incrementing it will mean you can't reuse it again...", "You don't necessarily have to do two pointers on the original array. Maybe do it on some other condition that should be satisfied", 'Also just consider doing two pointers directly (maybe that condition must be increasing or something) to make the implementation simpler']
USACO 2015 US Open, Silver: Trapped in the Haybales (Silver)
['Make sure to test possible states where another list DOES NOT move (e.g. j = 0)', "Maybe just run through all lists starting at 0,0 if your dp already safeguards against statements that don't make sense", 'Carefully read through the problem']
USACO 2016 December Contest, Gold: Cow Checklist
['Consider all possible moves you can make for the answer', 'Be careful of not including the case of placing [1, 1] (root to the root), base cases like this']
USACO 2019 January Contest, Gold: Shortcut
['convert some mathematical condition into an expression; consider storing that expression (e.g. 1000T_i - 1000XW_i). Take advantage of floor since that means you can probably just use that', 'actually visualize/write out what you are trying to do', 'go backwards vs. going forwards (e.g. in a dp can be faster)', 'binary search/fix the answer as usual', "in a dp, make sure to set ONLY the base cases. maybe don't use set everything to 0"]
USACO 2018 US Open Contest, Gold: Talent Show
['consider representing the problem using a graph (string problems, e.g. replacing characters)', "consider merging characters that are equal (don't store the same node twice)", 'be careful of long longs! (If something exceeds 10^18 maybe just store 10^18; but DO NOT store under!)']
USACO 2023 January Contest, Gold: Find and Replace
['You can handle DP cases involving a permutation/repeating elements by first looping through the sum you want and then doing the dp transitions']
USACO 2019 January Contest, Gold: Cow Poetry
['Use 2D prefix sums to store the number of times two rectangles intersect', 'Try converting 1D to 2D?', 'Try reframing a problem involving rectangles to choosing the bottom/top/left/right. Consider different ways to choose the top/bottom/left/right', 'Prefix sums above a certain point can be thought of choosing things above/below some line', 'Try having multiple ways of wording the same thing? Change the wording -> new ideas?', 'Be careful about setting the coordinates when dealing with prefix sums in rectangles. Take a minute to think about this step.', 'Also be careful about including things of size = 1 and be careful that you may not want things to actually intersect a line (just below/above)']
USACO 2019 February Contest, Gold: Painting the Barn
['Binary search/fix the answer as usual', 'Think of points instead of intervals sometimes?', 'Try storing the maximum value/minimum value to achieve something instead of trying to check if a value works to achieve that', 'Have a vague idea and stuck? Explore that vague idea more', 'Be careful that doing some dp may not necessarily mean you can just go back 1. Double check this!', 'Be careful in binary searching, maybe have to do eps value 1e-6']
USACO 2016 January Contest, Gold: Angry Cows
['When we are trying to find a case that works for all possible starting points, one idea is to move all those starting points at once', 'Be careful of stopping when a problem tells you so. If you already reached an answer state, maybe avoid updating that in code', 'Read the sample case, actually try it out']
USACO 2016 December Contest, Gold: Lasers and Mirrors
['Binary search/fix the answer as usual', 'Maybe if something is going to take O(N) to check and you are increasing the answer, consider binary searching. Note that "increasing" the answer ends up being the same as fixing the answer so maybe binary searching can be a better solution', 'You can use a set/priority queue to store the order to pick something with the smallest order; when lexographically sorting something maybe this is a hint to involve sets in some way', "Don't get stuck on one approach", 'You can do topological sorting using a priority queue (this will give you the lexographically smallest) and if you reach a cycle then the queue will be empty']
USACO 2018 US Open Contest, Gold: Milking Order
["Don't really know what to do/how to motivate the solution", 'Going to write that using an array as balance seems to be a useful idea: subtract all vertices than go into u add all vertices that leave u']
Codeforces 1266D: Decreasing Debts
['Got the intended solution, but messed up on the implementation', 'First when trying to find the minimum sum of weights to connect something (make things available) consider MST', 'Think of the only moves we can do, what do those moves do? What can only be connected', 'Be careful of considering cells in a grid at the start and the end. Get a super clear plan before implementing', 'Consider optimizing a DSU by removing the size array and just storing parents (could work), consider making the amount of edges you use smaller (maybe just given the edge weight and some info you can find all edges versus storing those edges individually)']
USACO 2016 February Contest, Gold: Fenced In
['See what can be fixed in a problem (what must happen)']
USACO 2019 January Contest, Gold: Sleepy Cow Sorting
["Don't put methods you think don't work out of use; give it a try", 'Bit can be combined in a sweep to maintain conditions']
USACO 2017 February Contest, Gold: Why Did the Cow Cross the Road III
['Consider splitting the conditions to ones involving only one index at a time. E.g. for sorting, maybe find the minimum moves so A[j] < A[i] if j < i and A[j] > A[i] if i > j', 'Maybe consider drawing a line to split the array if dealing with conditions that involve moving only certain array values to the right locations', 'To find the number of values in the right location of an array, consider storing the indices and see the # in the right location (maybe sort those indices)']
USACO 2018 US Open Contest, Gold: Out of Sorts
["Consider storing something in a dp if it isn't already there. Maybe when assigning colors just store that in the dp."]
USACO 2017 December Contest, Gold: Barn Painting
['Consider drawing a graph of how something changes', 'Maybe see how you can make sure a certain quantity is greater than 0. Maybe convert what you are doing in a greedy regarding what you have regarding certain numbers??', 'One idea is to move the earliest thing possible in a greedy to the current location', 'Maybe consider moving numbers that are positive instead of concerning yourself with zeros?']
USACO 2016 February Contest, Gold: Circular Barn
['Consider merging vertices into one']
USACO 2020 US Open Contest, Gold: Favorite Colors
['Once again see if by solving n - 1, you can solve n (or some logic similar to this)', "Sometimes when minimizing answer/making things equal don't only consider the case where you decrease values, the case where you increase values may also be possible"]
USACO 2019 US Open Contest, Gold: Balancing Inversions
['Consider starting the dfs with (root, root) because you may not want depths greater than depth of tree to store 0 (want the root)']
DMOJ Another Contest 6 Problem 12 - A Pretty Standard Problem Involving Judge Kirito
['Consider storing only the number of digits/things that matter in a dp. Maybe for things in between two numbers A and B, just compute the answer directly', 'Consider using [L,R] to store what you have achieved especially if you add things to the beginning/end of some stack', "Consider storing the min location in which you deviate from numbers A, B if you are doing a problem like this. Don't get trapped in just having one variable to store if you have deviated from A/B"]
USACO 2023 February Contest, Platinum: Hungry Cow
['Consider swapping until you merge the largest subtree/thing with the current one', 'Consider breaking up a path between u and v as u->lca(u,v) v-> lca(u,v); if this path involves adding a value, consider writing the value across the path between u and v but remove it at lca', 'Consider needing to reconnect vertices u and v as a path across the graph']
USACO 2018 US Open Contest, Platinum: Disruption
['Consider trying the reverse of what you are doing if it is too slow (e.g. consider subtracting instead of adding from a larger set of possible elements)', 'Consider replicating what you are trying to do in the fast enough algorithm to make the moves you are doing fast enough', 'Take advantage of the fact in a merge small to large if the value for one vertice will be at least as large as the largest child. This means you want to remove the values from the multiset of the current vertice']
DMOJ APIO '12 P1 - Dispatching
['Consider writing out the actual dp values and simulating that to notice a pattern. This can help reduce the number of states', 'Complementary counting may be a better choice when dealing with "at least"..', "Don't get stuck on one approach as usual. Think about what you haven't used/haven't tried. Maybe write down a list of these things if stuck"]
USACO 2018 January Contest, Gold: Stamp Painting
['Consider storing only the number of digits/things that matter in a dp. Maybe for things in between two numbers A and B, just compute the answer directly', 'Consider using [L,R] to store what you have achieved especially if you add things to the beginning/end of some stack', "Consider storing the min location in which you deviate from numbers A, B if you are doing a problem like this. Don't get trapped in just having one variable to store if you have deviated from A/B", 'Also maybe reframe "deviating" from A/B as if [L,R] is less than or equal to (or maybe greater than) A[L,R]', 'Consider what will happen in A[j] is less than the start/end of the interval to come up with transition ideas']
USACO 2023 February Contest, Platinum: Hungry Cow
['Be careful that overlapping intervals (when setting things equal) may actually make sense. If [a,b] is fully contained in [c,d] then we can set [a,b] and [c,d] to both be the same', 'But still consider removing overlapping values to speed up the computation', 'Another cool idea is if you want one thing to satisfy a condition and another to not satisfy it, maybe just consider ONLY checking CONSECUTIVE things to lower the number of cases you check']
USACO 2023 February Contest, Platinum: Hungry Cow
['Consider trying what you thought "wouldn\'t work",', 'Be careful about cases when n = 1 or if there is only 1 color/1 type of thing']
USACO 2017 US Open Contest, Platinum: Modern Art
['Consider visualizing some operation involving reversing. See if you notice another way to frame it involving swaps', 'Consider applying a dp if you can make the choice to swap things in an array. See if one swap will affect another. Write down ideas you may be thinking of. Do something', "Remember not to forget about the quirks of the problem when setting up the dp. Don't forget to account for swaps"]
USACO 2017 January Contest, Platinum: Subsequence Reversal
['Ask questions, try to generate test cases to answer those questions', 'Maybe make things consecutive than not consecutive, decrease values by 1, generate test caes that will make something fail']
USACO 2017 December Contest, Platinum: Greedy Gift Takers
['Ask better questions, replace size of interval with leftmost point/rightmost point?', "Don't get stuck on only including the maximum number such that a certain condition is satisfied. Maybe switch to the minimum number? (e.g. there's only 1 w/ that certain condition)"]
USACO 2016 US Open Contest, Platinum: 262144
["Remove what you don't need. See what you can ignore.", "Make sure to update n if you remove intervals, careful of not exceeding 0, watch out for dp states that aren't possible", "Note in a dp you don't automatically have to only go to the previous one, can skip some to find an optimal one"]
USACO 2018 January Contest, Platinum: Lifeguards
['In a range DP, consider the ways/condition of all intervals that lie completely within an interval [l, r]', 'You may have to choose a point to "split" the dp over. Maybe this point allows an interval to go through it']
USACO 2019 December Contest, Platinum: Greedy Pie Eaters
['Consider small cases like n = 2 when trying to figure out the order to do something in', 'Consider just swapping adjacent values when finding the order to sort an array or something, you can extend swapping adjacent values to sorting the array by a certain condition', 'Be careful of the time it takes to visit a tree. Note you may have an edge between the parent of that tree and the node you are currently at! Note the time to visit a tree is 2', '(sz[i] - 1)']
USACO 2023 February Contest, Gold: Fertilizing Pastures
["Be willing to write down everything you have tried. Don't get stuck on one approach", 'Note you can switch to storing a state in the dp as part of a pair in the dp array', "Keep in mind that dp should already store the cost to get from i to j. Don't have to brute force all indices from i to j if we move from i to i + 1 each transition"]
USACO 2023 US Open Contest, Gold: Pareidolia
['Consider reversing things in a problem (e.g. graph problem). When "removing" something consider "taking"/"picking" it up', 'use a bfs when you visit a vertex and see what moves you can make.', 'you can store vertices where if you get some certain condition, you can visit them. this prevents you from having to visit the same "parent" vertex twice', 'note when removing something, you may be able to visit it if the path to get it is "length 1". maybe something regarding it is the same so you can "pick it up"', 'be careful of checking if you can visit a node the first time around']
USACO 2023 US Open Contest, Gold: Custodial Cleanup
['Use binary search to find the min value or max value for something.', "Just because a number is less than 10^18 doesn't mean adding it to something will satisfy that condition", 'Be careful of the calculations you are running, drawing a picture can help', 'Consider drawing a picutre of the situation to get a better crasp of how to construct a solution']
Codeforces 1080D: Olya and magical square
['When finding the diameter of the tree, you want to consider "unraveling" the tree so the root is one of the endpoints of the diameter', 'Consider breaking down a problem into one with smaller numbers', 'Consider greedily finding the point with the longest distance from the diameter?']
Codeforces 1294F: Three Paths on a Tree
["If you need to find dp[certain number moves][i], consider using binary lifting so you don't have to store everything", 'Consider breaking up a cyclic shift into a_l..a_n and a_1..a_l-1', "Consider storing the min moves to end at a certain location/min moves to start at a certain location to a certain fixed ending. Basically set up the dp so you can fix the ending if you don't want to store the number of moves."]
Codeforces 1142B: Lynyrd Skynyrd
['First if you think a solution is too slow, actually analyze it before stopping. Maybe write this down?', 'For each query, consider the minimal amount of time needed to process it. Maybe see if there are two options', 'Consider using a segment tree to store the INDEX with the MAX/MIN value. Then to find the MAX/MIN of a range, you can BREAK IT UP using the INDICES of the segment tree. (You can also consider just storing the value directly)']
Codeforces 1514D: Cut and Stick
['When doing a bitmask problem, consider comparing each bit at a time. When comparing with two numbers, consider the place where the bits first differ', 'When having to store if two elements share some number trait, consider sorting an array with those traits (efficient constant optimization) or use a "trie" like structure (store the value in the trie and store the values of the children in an array). Then you find inversions or something using the trie based on the order you process things in']
Codeforces 1146C: Tree Diameter
